# Internet 

Интернет основан на модели TCP/IP

Модель TCP/IP — это стек протоколов, которые задают правила передачи данных по Сети.

Протокол - набор правил и действий.

**TCP** (Transmission Control Protocol) отвечает за обмен данными. Он управляет их отправкой и следит за тем, чтобы они дошли до получателя в целости. 

**IP** (Internet Protocol) отвечает за адресацию. Его задача — связывать друг с другом устройства и нарезать данные на пакеты для удобной отправки. Чтобы протокол мог быстро найти дорогу от одного компьютера к другому, придумали IP-адреса — уникальные идентификаторы, которые есть у каждого устройства в Сети.

Версии IP: IPv4, IPv6

Но протоколами TCP и IP модель не ограничивается — например, есть ещё HTTP, FTP, UDP и сотни других. Все они заточены под определённые задачи. Так, HTTP помогает браузеру формировать запросы к серверу, FTP — скачивать файлы, а UDP — быстро передавать видео, музыку и игры, но с возможными потерями по пути.

## Из каких уровней состоит TCP/IP?

1. канальный уровень — отвечает за взаимодействие по сетевому оборудованию, например по Ethernet-кабелю или Wi-Fi;

**Для чего нужен:** устанавливать физическое соединение между устройствами в локальной сети с помощью радиоволн и проводов.

**Как работает:** данные делятся на небольшие кусочки (фреймы) и передаются между устройствами. Каждый фрейм содержит часть передаваемой информации и служебные данные.

2. сетевой уровень — помогает отдельным сетям общаться друг с другом;

**Для чего нужен:** строить маршруты между устройствами по всему интернету — этот процесс называется маршрутизацией.

**Как работает:** IP-протокол вычисляет местонахождение устройств по их IP-адресам, а также строит до них кратчайшие пути и делит данные на пакеты

3. транспортный уровень — отвечает за передачу данных между устройствами, например, по протоколам TCP и UDP;

**Для чего нужен:** передавать данные по маршруту, построенному на предыдущем уровне.

**Как работает:** устанавливает надёжное соединение между устройствами, а затем следит за передачей данных по нему и исправляет ошибки.

На транспортном уровне есть два протокола: TCP и UDP

4. прикладной уровень — помогает приложениям общаться друг с другом с помощью интерфейсов или API

**Для чего нужен:** настраивать связи между приложениями — например, между браузером и серверным софтом.

**Как работает:** использует различные протоколы и сервисы, которые помогают приложениям обмениваться данными по интернету.


## HTTP / HTTPS

Регламинтирует как упаковывать передаваемые данные, чтобы браузер мог их загружать и отображать

Методы https запросов: **GET, HEAD, POST, PUT, DELETE, OPTIONS**

HTTP запрос состоит из: метода, заголовков, тела

Статусы HTTP запросов:

**1xx** — Информационные

**2xx** — Успешные коды ответа

**3xx** — Коды редиректов

**4xx** — Ошибки со стороны клиента

**5xx** — Ошибки со стороны сервера

Цикл отпарвки данных по HTTP:

1. Данные
2. Данные упаковываются в HTTP сообщение
3. Данный дробится на сегменты и упаковывается в TPC пакеты
4. Упаковывается в IP пакеты
5. Упаковывается в кадры
6. Данные отправляются

HTTPS тоже самое, что и HTTP, но данные шифруются с помощью протоколов шифрования SSL/TLS

## Доменные имена

Доменное имя — альтернатива IP адресу

Одно доменное имя соответствует множеству IP адресов

DNS сервер занимается преобразованием доменного имени в IP адрес. DNS использует UDP.

## Как загружаются веб страницы

После того как установлено TCP-соединение браузер может начать фетчинг ресурсов сервера.

Первый запрос к серверу обычно является GET-запросом на получение HTML-файла

**1. Парсинг HTML**

После того как браузер получил HTML-файл он парсит его для создания DOM (Document Object Model)-дерева.

Это делается при помощи движка браузера, который является его ядром

Первый шаг на пути к отображению веб-страницы - это токенизация HTML-файла. Токенизация - это процесс деления строки символов на значимые чанки для браузера, именуемые токенами.

Токены являются базовыми строительными блоками DOM-дерева.

**Строительство DOM-дерева**

Лексинг (lexing) - это процесс конвертации токенов в древовидную структуру именуемую DOM-деревом.

DOM-дерево - это древовидная структура данных, которая представляет собой ноды в HTML-документе.

Заметка: если для страницы требуются какие-либо внешние ресурсы, то они будут обработаны следующим образом:

* Не блокирующие ресурсы загружаются параллельно (Пр.: картинки)

* Отложенные ресурсы загружаются параллельно, но выполняются после того как будет построено DOM-дерево. Пр.: скрипты с атрибутом defer и CSS-файлы.

* Блокирующие ресурсы загружаются и выполняются последовательно. Пр.: скрипты БЕЗ атрибута defer.

**2. Парсинг CSS**

После того как DOM-дерево построено, браузер парсит CSS-файлы для создания CSSOM (CSS Object Model).

Этот процесс аналогичен построению DOM-дерева с использованием токенизации и генерации CSSOM.

**3. Выполнение JavaScript**

Если у страницы есть блокирующий скрипт, то он будет загружен и обработан незамедлительно, в то время как строительство DOM-дерева будет отложено, либо же скрипт будет загружен и выполнен после того, как DOM-дерево будет полностью создано.

Независимо от того когда выполняется скрипт, он будет обработан движком JavaScript, который похож на движок браузера и зависит от того какой браузер используется.

**4. Рендеринг**

Для рендеринга браузер использует DOM-дерево и CSSOM.

**Построение дерева рендера**

Первый шаг - построить дерево рендера. Дерево рендера - это подмножество DOM-дерева, состоящее только из **видимых** на странице элементов.

**Компоновка (layout)**

Следующим этапом является компоновка дерева рендера. Она делается путем расчетов точных размеров и позиции каждого элемента в дереве рендера.

Этот этап происходит каждый раз, когда мы изменяем что-нибудь в DOM, что затрагивает компоновку страницы, даже частично.

**Отрисовка (painting)**

Наконец, браузер решает, какие ноды должны быть видимыми, и рассчитывает их позицию в области просмотра (viewport), после чего наступает время их отрисовать (сделать рендер пикселей) на экране. Этот этап также известен как этап растеризации, на котором браузер преобразует каждый элемент, рассчитанный на этапе компоновки, в реальные пиксели на экране.

Также как и этап компоновки, этот этап происходит каждый раз когда мы изменяем отображение элемента в DOM, даже частично.

Порядок отрисовки: в общих чертах, отрисовка начинается с заднего плана и постепенно переходит к переднему

**Наложение слоев и композиция** 

Финальный этап - композиция слоев. Это делается браузером для оптимизации процесса рендеринга.

Композиция (compositing) - это техника разделения частей страницы на слои, их отрисовки и дальнейшего составления из них страницы в отдельном потоке называемом композиторским потоком (compositor thread). Когда разделы документа рисуются в разных слоях, перекрывая друг-друга, композиция необходима для того что бы удостовериться, что они нарисованы в правильном порядке и их содержимое корректно отображается.

## XSS CSRF

**XSS** - Межсайтовый скриптинг или JS-инъекции. Позволяет выполнять произвольный JavaScript код в браузере пользователя-жертвы.

Если в html-документ вставить строку, в которой будут использоваться элементы, похожие на html-теги, то браузер будет интерпретировать их как валидный html-код и исполнять его. Например, можно прописать  с пустым src и добавить onerror=“alert(‘hacked’)” (так как src пустой, то браузер сразу перейдет к вызову onerror), внутри которого выполнить любой JS-код (имея доступ к localStorage и так далее).

Предотвращение JS-инъекций:

В современных фреймворках (вроде Angular/React) изначально действует санитизация, которую в случае необходимости (если вы хотите запустить inline-скрипт из строки и уверены, что там не содержится ничего вредоносного) можно отключить. В React’е это делается посредством атрибута, подчеркивающего опасность вставки inline-скриптов: **dangerouslySetInnerHtml**

**CSRF** - Межсетевая подделка запроса.

Этот вектор атаки использует склонность браузера неявно добавлять куки к любому запросу. Например, вы авторизовались на сайте, где используются куки, и в какой-то момент некий скрипт делает запрос на origin этого банка — то есть открыли почтовый клиент и перешли по вредоносной ссылке. Браузер автоматически добавит куки к запросу, даже если сам запрос происходит с другой вкладки.

Из-за SOP этот скрипт не будет иметь доступа к response. Но он сможет выполнять запросы на правах авторизованного пользователя. Например, сделать запрос на перевод денег или просто на удаление любой возможной информации.

Для предотвращения этой атаки в первую очередь рекомендуется использовать явные системы аутентификации. Например, session token / jwt в header или session token в body param. Также, если на сайте используется какая-то форма, то рекомендуется реализовывать anti-csrf token’ы. Их суть в том, что сервер в response отдаёт два случайных токена. Один предназначен для куков, другой прячется в скрытом поле формы. Когда клиент submit’ит форму, то должен отправить оба токена обратно на сервер. В случае, если они отличаются от того, что сервер выпустил изначально, сервер блокирует запрос.

## Разница между cookie, sessionStorage и localStorage

Веб-браузеры предоставляют несколько способов хранения данных на стороне клиента, таких как cookie, sessionStorage и localStorage.

**Cookie:**

- Cookie - это небольшие текстовые файлы, которые хранятся на компьютере пользователя.

- Cookie создаются сервером и отправляются в браузер, где они хранятся и отправляются об0ратно на сервер при каждом запросе.

- Cookie имеют ограничение по размеру (обычно до 4 КБ) и количество (обычно до 20).

- Cookie могут иметь срок годности, после которого они автоматически удаляются.

- Cookie могут быть доступны как на сервере, так и на клиенте.

- Cookie могут использоваться для хранения информации, такой как предпочтения пользователя, данные аутентификации и отслеживание состояния сеанса.

**sessionStorage**:

- sessionStorage - это механизм хранения данных, доступный только в рамках одной вкладки браузера.

- Данные, сохраненные в sessionStorage, остаются доступными только во время сеанса работы с текущей вкладкой браузера. При закрытии вкладки данные удаляются.

- sessionStorage имеет ограничение по размеру (обычно до 5 МБ).

- sessionStorage может использоваться для временного хранения данных, таких как состояние формы или временные настройки.

**localStorage**:

- localStorage - это механизм хранения данных, доступный в рамках одного домена.

- Данные, сохраненные в localStorage, остаются доступными даже после закрытия браузера и перезапуска компьютера.

- localStorage имеет ограничение по размеру (обычно до 5 МБ).

- localStorage может использоваться для хранения постоянных данных, таких как настройки пользователя или кэшированные данные.

**IndexDB** 

- Это объектно-ориентированная база данных на основе JavaScript для хранения на стороне клиента значительных объемов структурированных данных, включая файлы/блобы.

- Хранит практически любые значения по ключам, несколько типов ключей

- IndexedDB позволяет хранить и извлекать объекты, индексированные с помощью ключа

- Поддерживает транзакции для надёжности.

- Позволяет хранить больше данных, чем localStorage.

## CORS

Cross-Origin Resource Sharing (CORS) — механизм, использующий дополнительные HTTP-заголовки, чтобы дать возможность агенту пользователя получать разрешения на доступ к выбранным ресурсам с сервера на источнике (домене), отличном от того, что сайт использует в данный момент. Говорят, что агент пользователя делает запрос с другого источника (cross-origin HTTP request), если источник текущего документа отличается от запрашиваемого ресурса доменом, протоколом или портом.

В целях безопасности браузеры ограничивают cross-origin запросы, инициируемые скриптами. Например, XMLHttpRequest и Fetch API следуют политике одного источника (same-origin policy). Это значит, что web-приложения, использующие такие API, могут запрашивать HTTP-ресурсы только с того домена, с которого были загружены, пока не будут использованы CORS-заголовки.


## PII (Personally Identifiable Information) — персонально идентифицируемая информация: ФИО, телефон, email, паспорт, адрес и т.д.
Защита PII — это набор мер, которые предотвращают утечку или несанкционированный доступ к таким данным. Включает:

- Контроль доступа и аутентификация

- Шифрование данных (в хранении и передаче)

- Маскирование/анонимизация

- Логи и мониторинг

- Соответствие законам (GDPR, HIPAA и др.)

## CSP (Content Security Policy) — это HTTP-заголовок безопасности, который ограничивает, какие ресурсы можно загружать и выполнять на странице.
Нужен для защиты от XSS и атак, связанных с внедрением стороннего кода.

Позволяет указать:

- Откуда можно подгружать скрипты (script-src)

- Откуда можно подгружать стили (style-src)

- Разрешённые домены для изображений, iframe и др.

- Запрет или разрешение inline-скриптов

## Для чего используется WebSocket?


Протокол WebSocket («веб-сокет»), описанный в спецификации RFC 6455, обеспечивает возможность обмена данными между браузером и сервером через постоянное соединение. Данные передаются по нему в обоих направлениях в виде «пакетов», без разрыва соединения и дополнительных HTTP-запросов.

Чтобы открыть веб-сокет-соединение, нам нужно создать объект new WebSocket, указав в url-адресе специальный протокол ws:

``` let socket = new WebSocket("ws://javascript.info"); ```


Как только объект WebSocket создан, мы должны слушать его события. Их всего 4:

- open – соединение установлено,
- message – получены данные,
- error – ошибка,
- close – соединение закрыто.
